data cleaning (fixing null values, changing date to hr and min etc)
eda -> exploratory data analysis (findings found from cleaned sata)
featureEngineering -> up/down sampling,smote,label encoding for ml

how to check duplicates       -> df[df["column_name"].duplicated].shape
how to remove duplicates      -> df=df.drop_duplicates(subset=["column],keep="first")
to save cleaned data          -> df.to_csv("new_empty_file_path")

machine learning :- a branch of ai, where computer learn from data and make prediction or decision with out being explicitly
programmed for every case
in ml we give both input and output of that input to traint he ml to leran and predict 

steps involved in ml:
-> data observe
-> data collect
-> data cleaned
-> data analyse(eda)
-> feature engineering decide independant(input/features/x) and dependant(output/y) variable 
-> encoding data types of x and y 
-> split data into training data 80% and testing data 20%
-> feature scaling
-> select ml algorithm
-> train the model
-> evaluate the model

types of machine learning:
-> supervised machine learning :- used when there are independant(input) and dependant(output) variable
    -> classification :- output is a class 
        ->KNN(KnearestNeighbour),naivebayes,sym,decisiontree,randomforest
    -> regression :- output is numerical
-> unsupervised machine learning :- used when we have independant(input) and groups/cluster(output)

-> encoding types:
    -> label encoding: help in changing the class into int in Y
    -> OneHotEncoding: each class will craete a new column and the one with the value in it will be 1 and everyone else be 0 in X
        eg:-    country                                  india     america    france
                india                                      1          0          0
                france         after encoding with   ->    0          0          1                
                america           OneHotEncoding           0          1          0

we use scikit-learn library to scale data and many other ml functions

-> to scale all independant values
from sklearn.preprocessing import MinMaxScaler(uses min and max)/StandardScaler(uses mean and standard deviation)    -> this is how we import it
and we should create an object for the class MinMaxScaler
then    ->  scaler=MinMaxScaler()
            xscaled=scaler.fit_transform(x)
            xscaled

-> to train and test model
from sklearn.model_selection import train_test_split       -> this is how we import it
X_train,X_test,Y_train,Y_test=train_test_split(Xscaled,Y,test_size=0.2,random_state=anynum)     
#random_state makes sure that the test and train values are same every time we refresh and the num should be the same to get the same values

-> to change or add all null values at Once instead of fillna
from sklearn.impute import SimpleImputer     -> this is how we import it
imputer=SimpleImputer(missing_values=np.nan,strategy="mean")           ->create object and strategy=mean,mode,min,max,median
X.iloc[:,1:3]=imputer.fit_transform(X.iloc[:,1:3])

-> to encode a class into integers using OneHotEncoder in X:
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct=ColumnTransformer([("encoder",OneHotEncoder(),[column to be encoded])],remainder="passthrough")         ,no passthrouh then will only get encoded values all other will be gone
X=pd.DataFrame(ct.fit_transform(X))

-> to encode a class into int using label encoder in Y:
from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()
Y=le.fit_transform(Y)

KNN :- KnearestNeighbour:                                   
give a value for K      (value should always be odd number)
calculate the distance ( we use ucledian formulla  -> (x2-x1)^2 + (y2-y1)^1 )
sort the data
find the nearest neighbour
make a prediction

eg: k=3
00000000000                 111111111                    0000    |                  |    111
0000000                        111111      sort  ->      0000000 |                  | 111111
00000000           *        111111111            ->      00000000|        *       11|1111111
0000                              111                    00000000|000            111|1111111
here * has more closer values in 1s group than 0s so * == 1

