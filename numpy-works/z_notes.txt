all data is stored as binary values
iteration is a slow process 
we do not use list in numerical calculations as
    for list=[3]
list is saved as:
    type      00000000 00000000 00000000 00000001
    size      00000000 00000000 00000000 10000001
    obj value 00000000 00000000 00000000 00000011
this will make the size of list more and the speed at which it can be accesed is slower

so we use numpy(numerical pyhton) array instead: 
numpy(numerical pyhton) always have the same type of data
            arr=numpy.array([3])
            int16
it is saved as 00000000 00000011
data:num of rows and columns
numpy(numerical pyhton):library for processing this data
applications:ML,pandas,scikit

numpy has many methods like array,zeros,ones,full,randon to make arrays
to check the dimension of a variable we use                  -> var_name.ndim
to get the num of values in a variable we use                -> var_name.size
to get the num of rows and columns of the given array we use -> var_name.shape
1d array using                  -> arr[start:end]   #end excluded so 1:4 will give values of 1-3 only not 4
2d array using                  -> arr[row,column]
3d or multi-d array using       -> arr[level,row,column]
row --->  column|
                |
                v    
in (2,3) means 2 rows and 3 columns
we use axis to show weathehr touse row or column
    axis=0 -> column
    axis=1 -> row
to update  -> arr[row,column]=new_value
we can +,-,/,* all the array values -> new_array = array_name (+,-,/,*) value 
if we use math_symbol on two diff arrays the values in same index will be the solution of the given math operation 
when giving a condition use array_name[array_name condition value] if not the answer will come out in boolean values 
we use & symbol instead of and 
we use .astype to change a datatype

numpy has build in functions:
    read csv file                   -> np.loadtxt(file_path,delimiter=",",skiprow=1,dtype="str")
    sum                             -> np.sum(array_name,axis= 0/1)
    max                             -> np.max(array_name)
    argmax                          -> np.argmax(array_name)
    min                             -> np.min(array_name)
    argmin                          -> np.argmin(array_name)
    zeros                           -> np.zeros((row,column),dtype="int")   as its in float as default
    ones                            -> np.ones((row,column),dtype="int")   as its in float as default
    full given val                  -> np.full((row,column),give a val to fill)
    eye                             -> np.eye(row,column)   create zero matrix and fill ones in x,x locations
    avgerage                        -> np.average(array_name,axis= 0/1)
    random                          -> np.random.rand(row,column)
    random int                      -> np.random.randint(low,high,shape=(row,column))
    count_nonzero                   -> np.count_nonzero(array_name==value,axis= 0/1)
    where                           -> np.where(condition,true_val_replace,false_val_replace)
    vertical stacking               -> np.vstack(arr1,arr2)   
    horizontal stacking             -> np.hstack(arr1,arr2)
    reshape                         -> np.reshape(array_name,shape=(row,column))          should be similar shape 
    flatten                         -> np.ravel(arr)   or  arr.flatten()
    matrix multiplication           -> np.dot(arr1,arr2)
    sort                            -> np.argsort(arr)
    



